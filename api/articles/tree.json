{"title":"树的数据结构转化","slug":"tree","date":"2017-07-28T06:12:25.000Z","updated":"2018-05-11T09:21:59.000Z","comments":true,"excerpt":"","content":"<h4 id=\"一、问题描述\"><a href=\"#一、问题描述\" class=\"headerlink\" title=\"一、问题描述\"></a>一、问题描述</h4><p>相信做前端的小伙伴都有遇到过将一个平铺的 ‘树’ 结构转换成一个真正的 ‘树’ 结构，比如说下面这种：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5082102-6ea74416d2860e7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/590\" alt=\"\"></p>\n<p>最终要转换成类似如下的格式，方便在页面渲染：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5082102-f100df7026e71a49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<p>你的方法是什么样的呢？思考中…</p>\n<h4 id=\"二、代码鉴赏\"><a href=\"#二、代码鉴赏\" class=\"headerlink\" title=\"二、代码鉴赏\"></a>二、代码鉴赏</h4><p>相信有的小伙伴会是和网上大多数能搜到的答案一样，用好几个循环来实现，在这里给大家解读一下，我认为看到代码最少的一种解决方案，该方案出自FCC成都社区的水歌之手，Jsbin代码地址：<a href=\"https://jsbin.com/budapagito/edit?html,js\" target=\"_blank\" rel=\"noopener\">https://jsbin.com/budapagito/edit?html,js</a></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5082102-19da4480f77be890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<h4 id=\"三、知识点分析\"><a href=\"#三、知识点分析\" class=\"headerlink\" title=\"三、知识点分析\"></a>三、知识点分析</h4><p>在看一段代码时，我们首先要了解里面涉及到的知识点(从方法入口开始)：</p>\n<ul>\n<li>1、<a href=\"https://link.jianshu.com/?t=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\" target=\"_blank\" rel=\"noopener\">JSON.stringify(Array2Tree(<em>JSON</em>), null, 4) </a></li>\n</ul>\n<blockquote>\n<p>将Array2Tree(<em>JSON</em>)这个函数返回的数据处理成Json，’4’代表缩进4空白字符串，用于美化输出（pretty-print）</p>\n</blockquote>\n<ul>\n<li>2、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments\" target=\"_blank\" rel=\"noopener\">arguments[0]</a></li>\n</ul>\n<blockquote>\n<p>arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。这里的arguments[0]实际就是取得我们传入函数的<em>JSON</em>数组。</p>\n</blockquote>\n<ul>\n<li>3、<a href=\"https://www.jquery123.com/jQuery.extend/\" target=\"_blank\" rel=\"noopener\">$.extend()</a></li>\n</ul>\n<blockquote>\n<p>描述：将两个或更多对象的内容合并到第一个对象。</p>\n</blockquote>\n<blockquote>\n<p>也可以是$.extend(boolean,dest,src1,src2,src3…)</p>\n</blockquote>\n<blockquote>\n<p>第一个参数boolean代表是否进行深度拷贝不含第一个参数boolean，它的含义是将src1,src2,src3…合并到dest中,返回值为合并后的dest,由此可以看出该方法合并后，是修改了dest的结构的。所以这里$.extend(true, [ ], arguments[0])的意思就是把传的<em>JSON</em>数组合并到一个空的数组 [ ] 上去, 保证后续的操作不会改变arguments[0]的结构。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">备注：$.extend(true, [ ], arguments[0]) , 也是可以直接遍历arguments[0]：</span><br></pre></td></tr></table></figure>\n<ul>\n<li>4、<a href=\"https://www.jquery123.com/jQuery.each/\" target=\"_blank\" rel=\"noopener\">$.each()</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery的each方法是跟each的语义一样是遍历的作用。</span><br><span class=\"line\"></span><br><span class=\"line\">当我们第一参数是Array时：</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5082102-cddf8166ad57b3f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<ul>\n<li>5、<em>This</em> = TempMap[ this.id ] = <em>This</em> ? $.extend(this, <em>This</em>)  :  this;</li>\n</ul>\n<blockquote>\n<p>这个里面包含两个知识点：</p>\n</blockquote>\n<blockquote>\n<p>三目运算符： let variable = a ? b : c 即： a 可以是任意可以转换成boolean类型的值或者运算，如果a为true的话，上式等同于let variable = b; 否则 上式等同于let variable = c；</p>\n</blockquote>\n<blockquote>\n<p>a = b = c ： 等同于 b = c, a = b（注：只有 a 是可以在这里声明变量的）。</p>\n</blockquote>\n<ul>\n<li>6、逻辑或( a || b )运算的妙用</li>\n</ul>\n<blockquote>\n<p>逻辑或运算( a || b )，其中a、b可以是 boolean 类型或者任意能转换成 boolean 类型的数据类型或者运算。在此段代码中巧妙的运用到了变量的初始化上。a || b 运算的执行过程，只有当 a 为 false 时 才会执行 b, 只有 a 和 b 两都是 false 会返回 false，否则返回a 或者 b，取决于 a 是否是true 或者是否可以转换为true。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">补充个基础知识：在 js 的逻辑判断中 null, 0, undefined, &apos;&apos;, &quot;&quot; 都可以转换为 false。</span><br></pre></td></tr></table></figure>\n<h4 id=\"四、思路分析\"><a href=\"#四、思路分析\" class=\"headerlink\" title=\"四、思路分析\"></a>四、思路分析</h4><ul>\n<li><p>1、在 Array2Tree 函数作用域内声明一个 TempMap 的变量名，用于每项数据引用的临时存储</p>\n</li>\n<li><p>2、使用 $.each() 函数对 $.extend(true, [ ], arguments[0]) 得到的新数组进行遍历，$.each() 的第二个参数是一个匿名 function(){}, 我们在 function(){} 里对每个数据进行处理，最终放置到变量 TempMap 中</p>\n</li>\n<li><p>3、在 function 的作用域中，this 指向每次遍历中 Array 的当前元素。比如说第一次进入 function() 中的 this就是：{id :7, name: ‘猪’, pid: 2}</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _This_ = TempMap[ <span class=\"keyword\">this</span>.id ];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>// 寻找 TempMap 对象中 key 为 this.id 的对应值。因为每一个数据的id是唯一的，所以这里的<em>This</em>得到的值只有两种可能: undefined 或者 { children：[object …] }(这种情况是由后面的代码赋值而生成的)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_This_  = TempMap[ <span class=\"keyword\">this</span>.id ] =  _This_ ? $.extend( <span class=\"keyword\">this</span>, _This_ ) : <span class=\"keyword\">this</span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>// 如果在 TempMap 中没有找到 key 为 this.id 对应的值，也就是 <em>This</em> =  undefined 的情况，则把 this 直接赋值到 TempMap[ this.id ] 中去，并且让 <em>This</em> 指向 this</p>\n</blockquote>\n<blockquote>\n<p>// 如果找到了，就合并 <em>This</em>  到 this 对象上，然后再赋值给 TempMap[ this.id ]，最后让 <em>This</em> 指向 this。具体合并的效果可以看下面的例子：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.extend(&#123;<span class=\"attr\">id</span>: <span class=\"number\">4</span>,  <span class=\"attr\">name</span>: <span class=\"string\">'鸡'</span>,  <span class=\"attr\">pid</span>: <span class=\"number\">1</span>&#125;, &#123;<span class=\"attr\">id</span>: <span class=\"number\">4</span>,  <span class=\"attr\">name</span>: <span class=\"string\">'鸡'</span>,  <span class=\"attr\">pid</span>: <span class=\"number\">1</span>, <span class=\"attr\">children</span>: &#123;<span class=\"attr\">id</span>: <span class=\"number\">13</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"三黄鸡\"</span>, <span class=\"attr\">pid</span>: <span class=\"number\">4</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5082102-316cd8fa8fe364cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/546\" alt=\"\"></p>\n<blockquote>\n<p>重要：这一步保证当前遍历的元素之前的子元素能给 ‘穿’ 到 TempMap[ this.id ] 上 ( ‘穿’ 理解成穿针引线一般的感觉)。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.pid = <span class=\"keyword\">this</span>.pid || <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>// 获取当前被遍历的元素的 pid, 没有 pid 的默认为第一层，并赋予 this.pid = 0。这里不一定非得是0，只要能和别的id区分开来就可以，这里采用0，是因为数据库的索引一般从1开始计数。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _Parent_ = TempMap[ <span class=\"keyword\">this</span>.pid ] = TempMap[ <span class=\"keyword\">this</span>.pid ] || &#123; &#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>// 判断 TempMap[ this.pid ] 是否是 undefined 。如果 TempMap[ this.pid ] 是 undefined，则 给TempMap[ this.pid ]赋值为{}，并且把 <em>Parent</em> 初始化为 {}。否则 TempMap[ this.pid ] 不是 undefined时，则把 <em>Parent</em>  指向 TempMap[ this.pid ]。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">( _Parent_.children = _Parent_.children || [ ] ).push( _This_ );</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>// 因为相比而言赋值运算的优先级相对别的要低一些，所以采取 ( <em>Parent</em>.children = <em>Parent</em>.children || [ ] ) 方式保证 <em>Parent</em>.children 始终不是 undefined，并且是 array 类型。在这个条件下，我们把 <em>This</em> 存进<em>Parent</em>.children</p>\n</blockquote>\n<p>重要：在这一步保证当前遍历的元素能被 ‘穿’ 到对应的父元素上去。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> TempMap[ <span class=\"number\">0</span> ].children;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>// 最终 TempMap 在本列中会变成如下形式：</p>\n</blockquote>\n<p>一个 key 为 0, 1, … 14, 15 的 Object<br>而展开之后，我们会发现想要的 ‘真正的树’ 就是TempMap[ 0 ].children，效果见本文的第二张图。那这又是什么样的结构呢？可以这么说 TempMap[ 0 ].children 是这棵树结构的整体，而其余的1 至 15 是每个对应的this.id 的分支。</p>\n<p>补充一点：为什么在<em>Parent</em>.children赋值后，我们的TempMap[ this.pid ]也随之改变，这里就涉及到引用数据的知识点了。在这里因为<em>Parent</em> = TempMap[ this.pid ]，所以它们来指向同一个内存空间，在<em>Parent</em>改变后，内存空间中的值也就改变了，所以TempMap[ this.pid ]的值也就相应的改变了。也正是引用类型的数据的这个特点，保证了我们的无论多少层的子元素都能被正确的 ‘穿’ 到了对应的父元素上 </p>\n<h4 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h4><p>万丈高楼始于平地，打好基础知识异常重要！</p>\n<p>文章出自 FCC(freeCodeCamp) 成都社区，欢迎大家的加入，和我们一起讨论、学习～</p>\n","thumbnail":["/img/bg/b.jpg"],"categories":[{"name":"code","path":"api/categories/code.json"}],"tags":[{"name":"jQuery","path":"api/tags/jQuery.json"},{"name":"黑魔法","path":"api/tags/黑魔法.json"}]}